#! /bin/bash
#
# Helpers for testing `log` module output
#
# You must source `_GO_CORE_DIR/lib/testing/environment` before this file.

. "${BASH_SOURCE[0]%/*}/stack-trace"
. "$_GO_CORE_DIR/lib/bats/helper-function"
. "$_GO_CORE_DIR/lib/bats/assertions"

# Log timestamps are disabled by for testing by default.
export _GO_LOG_TIMESTAMP_FORMAT=

# Creates a `./go` script that imports the `log` module
#
# If `TEST_LOG_FILE` is defined, it will add that file for logging output as
# well.
#
# Globals:
#   TEST_LOG_FILE:  (Optional) Path to the log file to add for all log levels
#
# Arguments:
#   ...:  Lines comprising the `./go` script
@go.create_log_script(){
  set "$DISABLE_BATS_SHELL_OPTIONS"
  @go.create_test_go_script \
    ". \"\$_GO_USE_MODULES\" 'log'" \
    'if [[ -n "$TEST_LOG_FILE" ]]; then' \
    '  @go.log_add_output_file "$TEST_LOG_FILE"' \
    'fi' \
    "$@"
  restore_bats_shell_options "$?"
}

# Creates and executes a `./go` script that imports the `log` module
#
# Globals and arguments are identical to `@go.create_log_script`.
@go.run_log_script() {
  @go.create_log_script "$@"
  run "$TEST_GO_SCRIPT"
}

# Format a `log` module log level label
#
# Arguments:
#   label:  Log level label to format
@go.format_log_label() {
  set "$DISABLE_BATS_SHELL_OPTIONS"
  local label="$1"

  . "$_GO_USE_MODULES" 'log'
  _@go.log_init

  local __go_log_level_index=0
  if ! _@go.log_level_index "$label"; then
    printf 'Unknown log level label: %s\n' "$label" >&2
    exit "$_GO_EC_NOTFND"
  fi
  printf '%s' "${__GO_LOG_LEVELS_FORMATTED[$__go_log_level_index]}"
  restore_bats_shell_options "$?"
}

# Validates that `output` matches the expected `@go.log` output
#
# Each line can be expressed one of two ways:
# - As a pair of strings: first the log level label, then the log message
# - As a single string without a log level label prefix
#
# Each log level label must exist within `_GO_LOG_LEVELS`, and can be either a
# plaintext label or a label formatted with `format_log_label`. Any unknown
# labels will be parsed as "a single string without a log label prefix".
#
# If the log label contains format codes, a formatting reset code will
# automatically get appended to the expected log message, so there's no need to
# add it explicitly.
#
# If you aren't looking for exact log output, consider using one of the standard
# assertions from `_GO_CORE_DIR/lib/bats/assertions` instead.
#
# Note that this does NOT handle timestamps. If you wish to validate specific
# timestamps, see `_GO_CORE_DIR/tests/log/timestamp.bats` for ideas.
#
# Arguments:
#   ...:  Lines of expected log output
@go.assert_log_equals() {
  set "$DISABLE_BATS_SHELL_OPTIONS"
  __@go.assert_log_equals "$@"
  restore_bats_shell_options "$?"
}

# Validates that a file matches the expected `@go.log` output
#
# Aside from the first file path argument, the remaining arguments and semantics
# are exactly the same as `@go.assert_log_equals`.
#
# In cases where `@go.log_add_output_file` is used to add a `TEST_LOG_FILE` to
# all levels, and all test output comes from `@go.log`, this may be invoked
# following `@go.assert_log_equals` like so to ensure the log file output
# matches standard output and standard error:
#
#   @go.assert_log_file_equals "$TEST_LOG_FILE" "${lines[@]}"
#
# If you aren't looking for exact log output, consider using one of the standard
# assertions from `_GO_CORE_DIR/lib/bats/assertions` instead.
#
# Arguments:
#   log_file:  Path to the log file to validate
#   ...:       Lines of expected log output
@go.assert_log_file_equals() {
  set "$DISABLE_BATS_SHELL_OPTIONS"
  local log_file="$1"
  shift

  if ! set_bats_output_and_lines_from_file "$log_file"; then
    restore_bats_shell_options '1'
  else
    @go.assert_log_equals "$@"
    restore_bats_shell_options "$?"
  fi
}

# Creates `LOG_COMMAND_STACK_TRACE_ITEMS` to help validate stack trace output.
#
# Call this before using "${LOG_COMMAND_STACK_TRACE_ITEMS[@]}" to inject
# entries from `@go.log_command` into your expected stack trace output. This
# helps validate stack trace output generated by logged commands, and ensures
# that your stack trace validation stays up-to-date even when the internal
# structure of `lib/log` changes.
#
# Globals:
#   LOG_COMMAND_STACK_TRACE_ITEMS:
#     Stack trace lines from `@go.log_command` comprising the command logging
#     mechanism
@go.set_log_command_stack_trace_items() {
  set "$DISABLE_BATS_SHELL_OPTIONS"
  if [[ "${#LOG_COMMAND_STACK_TRACE_ITEMS[@]}" -eq '0' ]]; then
    export LOG_COMMAND_STACK_TRACE_ITEMS
    LOG_COMMAND_STACK_TRACE_ITEMS=(
      "$(@go.stack_trace_item "$_GO_CORE_DIR/lib/log" \
        '_@go.log_command_invoke' '  "${__go_log_command_args[@]}" 2>&1')"
        # For some reason, with the process redirection at the end of the
        # `while` loop, the stack trace reports the opening line of the function
        # definition, not the actual `done < <(_@go.log_command_invoke)` line.
      "$(@go.stack_trace_item "$_GO_CORE_DIR/lib/log" '@go.log_command')")
  fi
  restore_bats_shell_options "$?"
}

# --------------------------------
# IMPLEMENTATION - HERE BE DRAGONS
#
# None of the functions below this line are part of the public interface.
# --------------------------------

# Implementation for `@go.assert_log_equals`, extracted for efficiency
#
# Arguments:
#   ...:  Lines of expected log output
__@go.assert_log_equals() {
  local __log_level_label
  local expected=()
  local i

  . "$_GO_USE_MODULES" 'format' 'log'
  _@go.log_init

  for ((i=0; $# != 0; ++i)); do
    if __@go.parse_log_level_label "$1"; then
      expected+=("$__log_level_label $2")

      if [[ "${__log_level_label:0:1}" == $'\e' ]]; then
        expected["$((${#expected[@]} - 1))"]+=$'\e[0m'
      fi

      if ! shift 2; then
        printf 'ERROR: Wrong number of arguments for log line %d.\n' "$i" >&2
        return "$_GO_EC_ARGERR"
      fi
    else
      expected+=("$1")
      shift
    fi
  done
  assert_lines_equal "${expected[@]}"
}

# Determines whether a log level label is a valid member of `_GO_LOG_LEVELS`.
#
# If so, pads the label and assigns it to `__log_level_label`.
#
# Arguments:
#   level_label:  Log level label to examine
#
# Returns:
#   zero if `level_label` exists in `_GO_LOG_LEVELS`, nonzero otherwise
#   __log_level_label:  Assigned the padded version of `level_label` if valid
__@go.parse_log_level_label() {
  local level_label="$1"
  local try_level
  local __go_log_level_index

  @go.strip_formatting_codes "$level_label" 'try_level'
  if [[ "$try_level" =~ \ +$ ]]; then
    try_level="${try_level%${BASH_REMATCH[0]}}"
  fi

  if ! _@go.log_level_index "$try_level"; then
    return "$_GO_EC_NOTFND"
  elif [[ "$level_label" != "$try_level" ]]; then
    __log_level_label="$level_label"
  else
    @go.strip_formatting_codes \
      "${__GO_LOG_LEVELS_FORMATTED[$__go_log_level_index]}" __log_level_label
  fi
}
