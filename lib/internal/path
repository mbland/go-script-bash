#! /bin/bash

. "$_GO_CORE_DIR/lib/internal/set-search-paths"

_@go.list_available_commands() {
  . "$_GO_CORE_DIR/lib/internal/commands"
  local __go_command_names

  if ! _@go.find_commands "$@"; then
    echo "ERROR: No commands available in:" >&2
    local IFS=$'\n'
    echo "${@/#/  }" >&2
    return 1
  fi

  echo "Available commands are:"
  local IFS=$'\n'
  echo "${__go_command_names[*]/#/  }"
}

_@go.set_command_path_and_argv() {
  if [[ "$#" -eq '0' || -z "$*" ]]; then
    return 1
  fi

  local path_suffix
  local try_path

  __go_cmd_name=()
  __go_argv=()
  __go_cmd_path=()

  for ((i = "$#"; i > 0; i--)); do
    for try_path in "${_GO_SEARCH_PATHS[@]}"; do
      path_suffix="$(printf '%s.d/' "${@:1:i}")"
      path_suffix="${path_suffix%.d/}"
      try_path="$try_path/$path_suffix"

      if [[ -f "$try_path" && -x "$try_path" ]]; then
        __go_cmd_path+=("$try_path")
        if [[ "${#__go_argv[@]}" -eq 0 ]]; then
          __go_cmd_name=("${@:1:i}")
          __go_argv=("${@:i+1}")
        fi
      fi
    done

    if [[ "${#__go_cmd_path[@]}" -ne 0 ]]; then
      break
    fi
  done

  # The command that is the most nested one takes precedence. Eg
  # `scripts/foobar/aaa/bbb/ccc arg1 arg2` takes precedence over
  # `scripts/foobar/aaa bbb ccc arg1 arg2`.

  if [[ "${#__go_cmd_name[*]}" -eq 0 ]]; then
    printf "Unknown command: $1\n\n" >&2
    _@go.list_available_commands "${_GO_SEARCH_PATHS[@]}" >&2
    return 1
  fi
}
